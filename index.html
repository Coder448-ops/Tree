<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate GPU Stress Test | Fractal</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #0ff;
            background: rgba(0, 0, 0, 0.85); padding: 20px; 
            border: 1px solid #0ff; border-radius: 5px; z-index: 100;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        .fps-counter { font-size: 30px; font-weight: bold; color: #00ff00; }
        .warning { color: #ff0000; font-size: 12px; margin-top: 5px; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>

    <div id="ui">
        <div>[ STATUS: MAX STRESS ]</div>
        <div class="fps-counter" id="fps">FPS: --</div>
        <div id="gpu-info">Target: RTX 3050 & Global GPUs</div>
        <div class="warning">DIQQAT: Videokarta qizishi mumkin!</div>
    </div>

    <canvas id="benchmark"></canvas>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() { gl_Position = vec4(position, 0.0, 1.0); }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision highp float;
        uniform vec2 u_res;
        uniform float u_time;

        // Mandelbulb algoritmi - har bir piksel uchun 12 marta iteratsiya
        float map(vec3 p) {
            vec3 z = p;
            float dr = 1.0;
            float r = 0.0;
            float power = 8.0 + sin(u_time * 0.1) * 2.0; 
            for (int i = 0; i < 12; i++) {
                r = length(z);
                if (r > 2.0) break;
                float theta = acos(z.z / r);
                float phi = atan(z.y, z.x);
                dr = pow(r, power - 1.0) * power * dr + 1.0;
                float zr = pow(r, power);
                theta = theta * power;
                phi = phi * power;
                z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
                z += p;
            }
            return 0.5 * log(r) * r / dr;
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * u_res.xy) / min(u_res.y, u_res.x);
            vec3 ro = vec3(0.0, 0.0, -2.5); // Kamera joylashuvi
            vec3 rd = normalize(vec3(uv, 1.0)); // Nur yo'nalishi
            
            float t = 0.0;
            int steps = 0;
            // Ray Marching: 128 qadam - GPU piksellarni hisoblashdan to'xtamaydi
            for(int i = 0; i < 128; i++) {
                vec3 p = ro + rd * t;
                float d = map(p);
                if(d < 0.0001 || t > 8.0) break;
                t += d;
                steps = i;
            }

            // Rang berish (VolumeShade uslubida neon effektlar)
            vec3 col = vec3(0.0);
            if(t < 8.0) {
                float iter = float(steps) / 128.0;
                col = vec3(0.1, 0.5, 0.9) * (1.0 - iter);
                col += vec3(0.5, 0.0, 0.5) * sin(u_time + t);
                col *= 2.0 / t; // Masofa yorug'ligi
            }
            gl_FragColor = vec4(col, 1.0);
        }
    </script>

    <script type="module">
        const canvas = document.getElementById('benchmark');
        const gl = canvas.getContext('webgl');

        // Shderlarni tayyorlash
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').text));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').text));
        gl.linkProgram(program);
        gl.useProgram(program);

        // Kvadrat chizish (Ekran bo'ylab)
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
        const pos = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(pos);
        gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);

        const resLoc = gl.getUniformLocation(program, "u_res");
        const timeLoc = gl.getUniformLocation(program, "u_time");

        let frameCount = 0;
        let lastTime = performance.now();

        function render(now) {
            // Rezolyutsiyani har doim yangilab turish (qiynash uchun)
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);

            gl.uniform2f(resLoc, canvas.width, canvas.height);
            gl.uniform1f(timeLoc, now * 0.001);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // FPS hisoblash
            frameCount++;
            if (now >= lastTime + 1000) {
                document.getElementById('fps').innerText = `FPS: ${frameCount}`;
                frameCount = 0;
                lastTime = now;
            }
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>
