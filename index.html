<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Extreme Benchmark</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #fps { 
            position: absolute; top: 10px; left: 10px; 
            color: #0f0; font-family: monospace; font-size: 24px;
            z-index: 10; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="fps">FPS: --</div>
    <canvas id="c"></canvas>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() { gl_Position = vec4(position, 0.0, 1.0); }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision highp float;
        uniform vec2 u_res;
        uniform float u_time;

        // Mandelbulb - Har bir piksel uchun og'ir matematika
        float map(vec3 p) {
            vec3 z = p;
            float dr = 1.0;
            float r = 0.0;
            float pwr = 8.0 + sin(u_time * 0.1) * 2.0;
            for (int i = 0; i < 15; i++) {
                r = length(z);
                if (r > 2.0) break;
                float theta = acos(z.z/r) * pwr;
                float phi = atan(z.y, z.x) * pwr;
                float zr = pow(r, pwr);
                dr = pow(r, pwr-1.0) * pwr * dr + 1.0;
                z = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta)) + p;
            }
            return 0.5 * log(r) * r / dr;
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * u_res.xy) / min(u_res.y, u_res.x);
            vec3 ro = vec3(0.0, 0.0, -2.5);
            vec3 rd = normalize(vec3(uv, 1.2));
            float t = 0.0;
            
            // 512 ITERATSIYA - Bu har qanday GPU-ni qiynaydi
            for(int i = 0; i < 512; i++) {
                float d = map(ro + rd * t);
                if(d < 0.0002 || t > 10.0) break;
                t += d;
            }

            vec3 col = vec3(0.0);
            if(t < 10.0) {
                vec3 p = ro + rd * t;
                col = 0.5 + 0.5 * cos(u_time + p.xyy + vec3(0,2,4));
                col *= 1.5 / t;
            }
            gl_FragColor = vec4(col, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('c');
        const gl = canvas.getContext('webgl');
        const fpsBox = document.getElementById('fps');

        function createShader(gl, type, source) {
            const s = gl.createShader(type);
            gl.shaderSource(s, source);
            gl.compileShader(s);
            return s;
        }

        const prog = gl.createProgram();
        gl.attachShader(prog, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').text));
        gl.attachShader(prog, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').text));
        gl.linkProgram(prog);
        gl.useProgram(prog);

        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
        const pos = gl.getAttribLocation(prog, "position");
        gl.enableVertexAttribArray(pos);
        gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);

        const resLoc = gl.getUniformLocation(prog, "u_res");
        const timeLoc = gl.getUniformLocation(prog, "u_time");

        let frames = 0, last = performance.now();

        function render(now) {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.uniform2f(resLoc, canvas.width, canvas.height);
            gl.uniform1f(timeLoc, now * 0.001);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            frames++;
            if (now >= last + 1000) {
                fpsBox.innerText = "FPS: " + frames;
                frames = 0;
                last = now;
            }
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>
